This project is a python simulator for Three-Address Code generated by a modified 483 P4 compiler

Table of Contents:
    1. Description of Three-Address Code (TAC)
    2. Repository Directory
    3. Comments on Simulation

1. Description of Three-Address Code (TAC)
    TAC is a pseudo-assembly instruction set, where each instruction has an operation and up to 3 operands, or addresses.
    TAC supports labels, instructions, and VTables.
    Labels can contain alphanumeric characters, underscores, and periods. Labels cannot begin with numbers.
    Labels are followed by colons (:) and then a newline or whitespace. 
    No other colons appear in TAC outside string constants and comments.
    There are many instruction formats. Each instruction is preceded by whitespace and followed by optional whitespace and a semicolon.
    Comments may appear after the semicolon.
    VTables begin with "VTable ", followed by the class name, then " =" and a newline, and then the list of elements in the VTable ending with a semicolon.
    Elements in the VTable begin with whitespace followed by the function name, a comma, and a newline.
    TAC supports the following instructions:
        Assignment: dest = src. Src may be an int constant, a string constant, a VTable reference, a Label, or an address.
        Load: dest = *(ref + offset). ref must be a reference. "+ offset" is optional and if not included, is 0.
            Offsets are byte-addressed. They will be divided by 4 to index into simulator arrays.
        Store: *(ref + offset) = src. Src can be the same as assignment. Ref and offset are the same as load.
        Binary Operation: dest = op1 b op2. op1 and op2 are the same as assignment's src. dest is the same as assigment's dest.
            b is one of "+", "-", "*", "/", "%", "==", "<", "&&", "||"
        Unconditional branch: Goto label. label must be a label.
        Conditional branch: IfZ test Goto label. label must be a label. Test is the same as assignment's src.
        Begin Function: BeginFunc fs (Formals). fs is a frame size in bytes.
            Formals is a list of the names of function arguments, in order that they appear on the stack.
        End Function: EndFunc. This is an implicit void return.
        Function Return: Return src. src is optional, and is the same as assignment otherwise.
        Push Parameters: PushParam src. src is the same as assignment.
        Pop Parameters: PopParams src. src is the number of bytes to be popped from the stack.
        Function Calls: dest = LCall label. "dest = " is optional, and is the same as assignment. label must be a label.
        Method Calls: dest = ACall src. "dest = " is optional, and is the same as assignment. src is the same as assignment.

2. Repository Directory
    The simulator scripts are in the root folder of the repository.
    Decaf compiler is in dcc. To run dcc, first cd into dcc, then call make, then run the executable dcc.
    The C++ code in the dcc directory had been modified to generate simulatable TAC (see section 3).
    The samples directory contains the decaf code from eecs483 project 4, along with the provided simulator output and 
        the TAC code generated by the modified dcc.
    truthgen.sh was used to automatically generate the TAC from the dcc executable.
    run test.sh to compare all TAC simulator output to the true output from the MIPS simulator.
        Note: the factorial test has incorrect output.
            Running the TAC simulator with -l will allow for 64 bit numbers and will get correct results.

3. Comments on Simulation
    The TAC code was not simulatable as-is. The main issue came from function parameters. While the dcc contained information
        about the order of function parameters to output to MIPS, the TAC did not contain this information. This has been added.
    Also, the MIPS code for built-in calls has been removed, and these are implemented in the simulator instead.
    The simulator has the following components:
        Array of TAC lines, with comments removed.
        Dictionary of address names to values.
        Dictionary of labels to line numbers.
        Dictionary of vtable names to arrays of function names
        Values can be numbers, string constants, or arrays of values. Decaf objects are represented as arrays
        Stack of values.
        Stack of return line indices.
        Return value register.